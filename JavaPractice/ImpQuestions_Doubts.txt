1. Importance of OOPs:
The importance of OOP in Java boils down to building maintainable, scalable, and robust applications that are easier to collaborate on.
Importance of OBJECT ORIENTED PROGRAMMING:

Encapsulation:(Modularity)
this is about creating self-contained units of code â€“ objects â€“ that bundle data and behavior
I've used encapsulation extensively to ensure data integrity and control access

Inheritance:(Code Reusability)
This isn't just about avoiding copy-pasting; it's about establishing clear 'is-a' (inheritance) and 'has-a' (composition) relationships to build upon existing functionality.

Polymorphism(Flexibility and Extensibility): It increases the extensibility and code resuability 
Instead of long if-else if chains or switch statements checking instanceof to determine an object's type and call specific methods (e.g., if (animal instanceof Dog) { ((Dog)animal).bark(); }), polymorphism allows us to write concise, generic code that handlesvarious types uniformly
This makes it incredibly easy to add new report types in the future without modifying existing code.

Abstraction(controlled access):
While encapsulation is about how an object's internal state is managed, abstraction is about hiding complex implementation details and exposing only the essential features or 'what' an object does


2. Use of JIT
I. Java Source Code (.java) â†’ Bytecode (.class):
First, you compile your Java source files using javac into platform-independent .class files containing bytecode.

II. JVM Loads and Interprets Bytecode:
When you launch a Java application (java YourMainClass), the JVM loads the necessary .class files. Initially, the JVM's interpreter starts executing the bytecode instruction by instruction. This allows for a quick startup time.

III. Hot Spot Detection (Profiling):
As the program runs, the JVM continuously monitors and profiles the execution. It keeps track of which methods, loops, or code blocks are being called or executed frequently. These frequently executed code segments are identified as "hot spots." The JVM maintains invocation counts for methods; when a method's invocation count crosses a certain threshold, it's flagged as a candidate for JIT compilation.

IV. JIT Compilation:
Once a method or code segment is identified as a hot spot, the JIT compiler (a component within the JVM) takes its bytecode and compiles it into highly optimized native machine code specific to the underlying CPU architecture (e.g., x86, ARM) and operating system (Windows, Linux, macOS). This compilation happens "just in time," while the application is running. 

3. Why java is both a compiled and interpreted language?
It undergoes an explicit compilation step (from .java to .class bytecode) by the javac compiler when we run a java program.

When you run a Java application, the Java Virtual Machine (JVM) loads these .class files. Initially, the JVM's interpreter component reads the bytecode instructions one by one and executes them directly. It translates each bytecode instruction into the underlying machine's specific instructions

Crucially, the JIT compiler dynamically compiles frequently executed bytecode into native machine code at runtime, blending interpretation with on-the-fly compilation for performance and optimization.

4. Role of Java classloader
- Dynamically loads the .class files for JVM execution
- Location .class files from different locations

5. Primitive and Non-Primitive Data Types:
In Java, primitive data types are the predefined, basic data types provided by the language to represent simple values.

On the other hand, non-primitive data types (also called reference types) are either:
Objects of classes (user-defined or built-in) â€” e.g., String, Scanner, custom classes
Arrays
Interfaces
Enums

6. How Java is pass-by-value?
Java is strictly pass-by-value, meaning it always passes a copy of variables to methods. 
For primitive types, the actual value is copied. 
For objects, the reference (memory address) is copied, allowing the method to modify the objectâ€™s internal state but not the reference itself.
Obj ob1 = new Obj(); // Object in memory at address 0x1234
method(ob1);         // You are passing the *value* 0x1234

int a = 5;
method(a);           // You are passing the *value* 5


7. Why Java allows default values at class level variables but not at method/local level?
Java allows default values for class-level variables (fields) because they are part of the object's state, 
which Java's runtime can control and initialize.
Java does not allow default values for local variables (inside methods) to prevent bugs and enforce explicit, safe programming practices.

8. Where Default Values Are Used:
Instance Variables (declared in a class but outside any method)
Static Variables (class-level variables)
Array Elements

9. Shallow copy vs Deep copy:
Shallow copy: A copy of an object where changing the state of a mutable reference-type field in the copy will also change the state of the original's corresponding field, because they both point to the same underlying object. 
However, changing a primitive field in the copy will not affect the original.

class Person {
    int age;
    String name;
    Address address; // A mutable reference-type object
}
Deep copy: A copy of an object where both the primitive and reference-type fields are fully independent of the original. Changing any state in the copy will not affect the original object.

10. Diff between ++a and a++?
(++a - value is updated, then used , a++ - value is used, then updated)

11. Wrapper class in Java
Wrapper classes in Java are a set of classes that allow primitive data types (like int, char, boolean, float, double, long, byte, short) to be treated as objects.

12. Widening and Narrowing type conversion
Widening is the conversion of a lower data type to that of a higher data type
int x = 20;
double y = x;
Narraowing is the conversion of higher data type to that of a lower data type
float f = 20.0;
int z = (int)f;

13. PSVM(PUBLIC STATIC VOID MAIN(String args[])
public: The main method is public so that JVM can call it from anywhere to start the program as main method
is the entry point of a program
static: A main method is static so that JVM can directly call it using the class name without needing to create the class object.
void: This indicates that the main method does not return any value. Once the program finishes its execution in the main method, it simply terminates.
main: This is just the name of a method which JVM looks for to start the execution.
String[] args: This is the parameter list. It specifies that the main method accepts a single argument, which is an array of String objects. These strings are typically used to receive command-line arguments when the program is executed.
For example, if you run a program from the command line like java MyProgram arg1 arg2, the args array inside the main method will contain {"arg1", "arg2"}.


14. How to make clone objects of Java - diff ways
- Using Cloneable Interface and clone method.
- Using Copy Constructor
- Using Serialization
- Using Reflection API
- Using SerializationUtils


15. Copy Constructors:
The concept of Copy Constructor is we will be creating a class in which we will be having a
constructor which will take the parameter of its own object and any reference type it will create newly.
as we can see in Student deep copy constructor, for courses, it is doing this.courses = new ArrayList<>();
It is the first step for making a deep copy.
Then from the object send in the copy constructor, we will copy the same contents in our reference type.
While copying, we will use the new keyword for example: here Course so that changing the course class values
also won't affect the original object which will eventually make it a deep copy.

More understandable with a coding example


16. Access Modifiers: Access modifiers in Java are keywords that control the visibility and accessibility of classes, interfaces, variables, methods, and constructors within a Java program. 
The Four Modifiers:

public: Accessible from anywhere.
protected: Accessible within the same package and by subclasses (even if they are in a different package).
default (package-private): Accessible only within the same package.
private: Accessible only within the same class.

17. Diff packages:
java.util: This is a collection of utility classes.
Common Classes: ArrayList, HashMap, Scanner, Date, Random.
Briefly: A toolbox of helpful, general-purpose classes.

java.lang: This package contains fundamental classes and interfaces that are essential for the Java language. 
Common Classes: String, Math, Integer, System, Object.
Briefly: The core building blocks of the Java language.

java.time: This package was introduced in Java 8 to provide a new, modern, and immutable date and time API. It offers significant improvements over the older java.util.Date and java.util.Calendar classes.
Common Classes: LocalDate, LocalTime, LocalDateTime, ZonedDateTime.
Briefly: A superior and modern API for handling dates and times.

java.io: This package provides classes for system input and output operations. It includes classes for reading from and writing to various sources, such as files, streams, and data buffers.
Common Classes: File, FileInputStream, FileOutputStream, BufferedReader, PrintWriter.
Briefly: The API for handling all types of input and output.

java.sql: This package provides the classes and interfaces for the Java Database Connectivity (JDBC) API. It is used for connecting to databases, executing SQL queries, and processing the results.
Commom Classes: Statement, Conenction, ResultSet etc.


18. What is an instance variable?

Expected Answer: An instance variable is a variable defined within a class but outside of any method, constructor, or block. Each object of the class will have its own copy of the instance variable.

19. What is a class variable (static variable)?

Expected Answer: A class variable is a variable declared with the static keyword. It belongs to the class itself, not to any specific object. There is only one copy of a static variable, shared by all objects of the class.

20. Class and Object:
Class is a blueprint or template for creating an object. It defines the state(field/variables) and behaviour(methods), an object will have. It is a logical entity.
Object is an instance of a class. It is a real-world entity which will have state and behaviour.
It is a physical entity that occupies some space in memory.

21. Marker Interfaces in Java
A marker interface is a special type of interface in Java that has no methods, no fields, and no constants. Its sole purpose is to "mark" or "tag" a class, providing extra information to the Java compiler, runtime environment, or other tools.

The java.lang.Cloneable and java.io.Serializable interfaces are two classic examples of marker interfaces.

When a class implements a marker interface, it tells the compiler or JVM that the class has a certain capability or property. For example:
 - Implementing java.io.Serializable tells the JVM that objects of this class can be converted into a stream of bytes and saved   	(serialized).

 - Implementing java.lang.Cloneable tells the Object class's clone() method that it is safe to make a field-by-field copy of an  instance.
 
22. Abstract Class vs. Interface 
Type of Members:
Abstract Class: Can have both abstract methods (with no body) and concrete methods (with a body).
Interface: Can only have abstract methods (with no body) before Java 8. From Java 8 and later, they can also have default and static methods.

Variables:
Abstract Class: Can have instance variables with any access modifier (private, protected, public).
Interface: All variables are implicitly public static final (meaning they are constants).

Constructors:
Abstract Class: Can have constructors.
Interface: Cannot have constructors.

Inheritance:
Abstract Class: A class can only extend one abstract class.
Interface: A class can implement multiple interfaces.

Access Modifiers:
Abstract Class: Members can have public, protected, default, or private access.
Interface: All members are implicitly public.

23. Singleton Class in Java:
A Singleton class in Java means irrespective of the number of times we are trying to create instance of the class, it will have
only single instance.
A Singleton class is a class that can have only one object (an instance) at a time. 
The purpose of a Singleton class is to control object creation, limiting the number of objects to only one We can achieve it through below steps:
1. private variable for the instance
2. private  constructor
3. class static method accessing the instance
Two types of Initialization: EAGER Initialization, LAZY Initialization

Disadvantages:
i)Hidden Dependencies and Tight Coupling Due To Global Access Point as in the getInstance method we don't have any parameters or 
refrence
ii)Difficult Unit Testing
iii)Issues with Concurrency and Scalability

When to use:
The Singleton pattern is best used as a last resort in modern Java development. If you find yourself thinking, "I need only one instance of this class," your first thought should be: "Can a Dependency Injection framework handle this for me?" 
If the answer is no, and the other conditions (no mutable state, a truly unique resource) are met, then a Singleton might be a justifiable choice.

24. Why Java does not support multiple inheritance through classes but through Interfaces?
Java does not support multiple inheritance through classes due to Diamond Problem.
Suppose a class A has a method doSomething();
Class B and Class C inherits Class A and provides their own implementation.
Now as part of multiple inheritance, if Class D inherits both Class B and C.
Now, if you create an object of Class D and call d.doSomething(), which version of the method should be executed?
This ambiguity is called as a Diamond Problem.

Class D extends B,C - Java Compiler does not support this syntax.

Java supports multiple inheritance through Interfaces?
A class can implement multiple interfaces.
Interfaces, by their nature, contain abstract methods (methods without a body) that must be implemented by the class.
Therefore, there is no ambiguity. The inheriting class is forced to provide its own, single implementation for the inherited methods.

25. Object Class:
It's the ultimate superclass of all other classes.Every class, whether it's a built-in class or a class you create, is a direct or indirect subclass of Object.
some object class methods- toString() , equals(Object obj), hashCode() , protected Object clone()

26. So why we should override Object class's equals method and provide our own implementations.
The Default behaviour of the Object class's equals(Object obj) method in the java.lang.Object class has the same behavior as the == operator. It checks for reference equality. This means it only returns true if both object references point to the exact same object in memory.It should compare the content not the references, that's why we need to provide our own implementations

Best Practice:
// Overridden equals() method for content comparison
    @Override
    public boolean equals(Object obj) {
        // 1. Check for reference equality (optimization)
        if (this == obj) {
            return true;
        }

        // 2. Check if the object is null or of a different class
        if (obj == null || this.getClass() != obj.getClass()) {
            return false;
        }

        // 3. Cast the object to the correct type
        PersonWithEquals other = (PersonWithEquals) obj;

        // 4. Compare the relevant fields
        return this.age == other.age && Objects.equals(this.name, other.name);
    }
	
27. Basic diff between Member Inner Class, method local Inner Class and static nested Inner Class
Member Inner Class:
Definition: A class defined as a member of another class, similar to how variables and methods are members. It is not declared with the static keyword.

Access to Outer Class: It has direct access to all members (static and non-static, including private) of the outer class. It is strongly tied to an instance of the outer class.

Instantiation: You must first have an instance of the outer class to create an instance of the member inner class.

Method-Local Inner Class:
Definition: A class defined within a method, a constructor, or a block of code.

Access to Outer Class: It can access all members of the outer class. Additionally, it can access local variables of the method, but only if they are declared as final (or are effectively final in Java 8 and later).

Instantiation: It can only be instantiated from within the method or block where it is defined. It is not accessible from outside that scope.

Static Nested Inner Class:
Definition: A class defined as a member of another class, but with the static keyword.

Access to Outer Class: It can only access the static members (methods and variables) of the outer class. It does not have access to the instance members because it is not associated with an instance of the outer class.

Instantiation: You can create an instance of a static nested inner class without an instance of the outer class.

28. String vs. StringBuffer vs. StringBuilder
String is an immutable object.
String is slow for concatenation.
It is generally used for fixed, constant data.

StringBuffer is mutable in nature
StringBuffer is slower than StringBuilder.
StringBuffer is thread-safe and is generally used in Multi-threaded environment.

StringBuilder is also mutable in nature
StringBuilder is the fastest
But StringBuilder is not thread-safe and is generally used in a single-threaded environment.

29. How to create your own immutable class in Java?
i) Lock down the class: Make the class final. No one gets to inherit from it and introduce mutable behavior. ðŸš«

ii) Lock down the fields: Make all fields private and final. They get one shot at initialization, and thatâ€™s it. ðŸ”’

iii)No shortcuts: Don't provide any setter methods. The state is fixed. ðŸ™…â€â™‚ï¸

iv)The Ultimate Safeguard: This is the part that separates the pros from the rest. For any mutable fields (like Date or List), you must provide defensive copies in both the constructor and the getter. 
This ensures outside code can't get a reference and modify your internal state. ðŸ›¡ï¸

30. StringJoiner , String class join() method.
The StringJoiner class, introduced in Java 8, is a utility for working with delimiters in a concise way. Instead of using the + operator, it allows you to easily set a prefix, suffix, and a delimiter between elements."

join(): String.join() is a static utility method. You don't need to create an object to use it. You simply call it directly on the String class itself (String.join(...)). Its purpose is to perform a simple, one-off task of joining a collection of elements

31. Array:
Array in Java is a data structure which has a fixed size and contains sequential collection of same data types.
We need to declare the size of an array while creating it. Once declared, we cannot change the size of an array.

32. MultiDimensional Arrays:
A multi-dimensional array is essentially an array of arrays. It allows you to store data in a grid-like or tabular format.
Visualize it as rows and columns int arr[i][j] ---> i means rows and j means columns

33. Jagged Arrays:
Jagged Array is a 2d-array but unlike 2d arrays, in a jagged array, each row has different number of columns.
Syntax:
int jaggedArr[][] = new int[3][];
    jaggedArr[0] = new int[2];
    jaggedArr[1] = new int[3];
    jaggedArr[2] = new int[5];
	
34. Association, Aggregation and Composition
Association represents the uni-directional or bi-directional relationship between two classes
where object of one class can interact with object of another class.

Aggregation is a type of association where it is considered to be a weak association
because the contained object here b1 for example, can survive without the container object (library)
It is because the object is not created inside the class rather it is created outside and then
send as a reference to the other class

Composition is a type of association where it is considered to be a strong association
because the contained object cannot survive without the container object. 
It is because the object is created insdie the class rather than sending it as a reference like we did in Aggregation.

Basically in Composition, inside the container class, we create the object of the other class 
so when we destroy the container class's object, automatically the contained object also gets destroyed and we can't 
access it.

35. Memory Management:
Memory management is the process of managing the allocation, dellocation of the memory for efficient flow of the program.
In Java, it is automatically managed by the JVM.

Important Components of Memory Management in Java:
i)Heap Memory:
Heap Memory is a large memory pool which is used for dynamic memory allocation i.e. memory allocation at runtime.
Heap Memory stores objects, instance variables, arrays, static variables, String pool etc.
Heap Memory is global for the entire application and can be shared by many threads.
Heap Memory is managed entirely by the Garbage Collector, any object which has no longer any reference pointing to it,
garbnage collector reclaims it's memory.
When we use new MyObject() the MyObject instance is created on the Heap.

ii)Stack Memory:
Stack Memory is basically used for static memory allocation.
It generally stores the Method's Stack frames(which are basically method calls,
for each method call, a stack frame is inserted into the thread's stack).
Stack frames consists of:
Local Variables, returned address of the method call, references to objects which are stored on Heap. 
As soon as the method gets executed completely, the stack frame also gets removed from the memory including the local variables etc etc.
Note: The objects on the Heap that were referenced by these local variables are not destroyed

iii)Local Variables: Variables which are declared inside the method, constructors.
These variables are in general stored in Stack Memory or method's stack frames.

iv)Object: Objects are always stored in the heap memory. Their existence is irrespective of the method in which they are created.
Objects are instance of a class

v)Dynamic Object Reference: A variable which holds the memory address of the object which is stored in the Heap.
The actual object it points to is allocated dynamically at runtime using the new keyword, hence the term "dynamic object reference.
The variable is stored in the Stack Memory.

36. Garbage Collector in Java:
i)Garbage Collector is basically Java's system for automatic memory management
ii)It finds and destroy the objects in the Heap which are no longer reachable and hence, reclaims the memory.
iii)The Java Heap is basically divided into 2 parts - Young Gen and Old Gen.
iv)The GC focuses most of it's effort on Young Gen where most of the objects die young.
v)System.gc() - We can use this to explicitly tell the JVM that it should run the Garbage Collector. 
But it totally depends on the JVM to run the Garbage Collector and using this is not recommended in production environments.

37. JVM Memory Allocation:
i)JVM is allocated memory by the OS
ii)JVM then, manages the memory based on the Heap size, which we can alter using -Xmx and that too depends on the system's RAM.
iii)When a new object is created (new Object()), the JVM allocates space for it in the Heap (usually the Young Generation).
iv)If there isn't enough space, the JVM will pause the application and run the GC to free up space
v)If that is not working, it will throw the OutofMemoryError and application will terminate.

38. Memory Leaks in Java:
i)Avoid static collections in Java or Excessive use of static fields                 
For Objects associated with these static fields, it becomes very difficult for the GC to reclaim the memeory of those objects.
As static fields lifetime is tied to the Class Loaderâ€”which is typically for the entire duration of the application.                                                                                                    
ii)Avoid non-static inner classes and use static nested inner class
iii)Proper use of equals and hashcode is needed to avoid HashMap leaks
iv)Closing the resources & collections. Use try-with-resources
If you open a database connection, a file stream (InputStream/OutputStream), or a network socket, 
and forget to call its close() method, the resource might remain active and unreleased. 
This often prevents the underlying memory buffers from being collected. 
v)Go for Weak Reference by using WeakHashMap.

39)final keyword, abstract keyword, super keyword.
Variable:	
final int X = 10;	
Makes the variable a constant. Its value can only be initialized once and cannot be changed later. 
Must be initialized either at declaration or within a constructor/initializer block.	
Method:	
public final void show() { ... }	
Prevents the method from being overridden by any subclass. 
This ensures that the method's implementation remains consistent across all inheritors.	
Class:	
final class Utility { ... }	
Prevents the class from being inherited (extended) by any other class. 
This is often done for security or to ensure an immutable design (e.g., the String class is final).

abstract keyword:
abstract keyword is used alongside a method and a class. 
Method:
An abstract method is a method with no body that is no implementation and only declaration.
An abstract method is always declared inside an abstract class
Class:
An abstract class is a class which can have both abstract as well as non-abstract method
An abstract class cannot be instantiated
A class which extends the abstract class, needs to override the abstract methods and provide it's implementation

super keyword:
super keyword is used to access the parent class variables
super keyword is used to call the parent's class constructor, given the super keyword should be
the first statement in the child class's constructor.
super keyword is also used to call the parent class's method

40)final vs finally vs finalize:
i)final: It is a non-access modifier which is used alongside variable, method and class to restrict the user-defined
ii)finally: It is an optional block of code which is used during exception handling for closing connections, resources, filestreams.
It is executed irrespective of any exception is thrown or not.
iii)finalize: It is a protected method of the Object class which was introduced as a method for cleaning up objects
before they are destroyed by the GC.
It is depreciated in Java 9 and now modern approaches like try-with-resources and Cleaner API are used where connections gets closed automatically.
Key Issue: There is no guarantee that finalize() will ever run, or if it does, exactly when it will run, making it unsuitable for essential cleanup.

41)Static Keyword:
i)Static Keyword is a non-access modifier used for memory management.
 * It can be applied to variables, methods, nested inner classes, blocks, and interfaces.
 * When a number is declared static, it belongs to the class rather than to any specific instance
 * It means that a single copy of static member is shared among the class and all of its instances.

ii) Static Variable:
Static Variable also belongs to the class and they cannot access non-static variables.
this or super keywords cannot be used inside a static method.
Commonly used as helper methods/utility methods.

iv) Static Blocks:
Static block is a block which is used for initializing the static variables.
It gets called whenever the class gets loaded in the memory
It cannpot access non-static or instance variables

v) Static nested class:
It is an inner class declared using the static keyword
It can access only the static members of the OuterClass.
TO access the inner static nested class, we don't need to create OuterClass objects

Use this syntax:
OuterClass.InnerClass innerClassObj = new OuterClass.InnerClass();
innerClassObj.display();

42) Can class be final or final static
i)Class can be final it just means the class cannot be inherited, generally used to create buikt-in immutable class
ii)A top-level class can never be static because static keyword for members meant it belongs to the class itself.
But that cannot be true for a top-level class as there is no outer class to which this class can belong to. So Java does not allow this.
However a nested inner class can be static not a top level class

43)Why Static members are not able to access non-static members but the opposite is possible?
It is because static members gets loaded when the JVM loads the class in the memory.
At this point of time, an instance is not created.
Also, for static members, there is no object reference,
But, the non-static members are loaded when an instance of the class gets created.
When they gets loaded in the memory, they already know the class information, so they can 
easily access the static members.

44)this keyword in Java:
this keyword is a reference keyword which is generally used for:
i)this keyword is used to resolve variable shadowing -> this.x=x;
ii)this keyword is used to return current object
Class obj1 = new Class();
Class obj2 = obj1.getObject(); -> 
Class.getObject(){
  return this;
}
iii) this keyword is a;so used for Constructor Chaining
//this must be the first statement
Class(){
  this(100);
  sout("Default Constructor");
}
Class(int x){
  sout("Parameterized Constructor");
  sout(x);
}

iv) this keyword is also used to pass the current class object
Class obj1 = new Class();
obj1.show(this);
void show(Class demoObj){
   demoObj.display();
}
void display(){
   sout("Display Method Gets Executed");
}

45)enum keyword in Java:
Enum keyword in Java is a special type of class that defines fixed set of constants.
Enums are implicitly final
Enums can have: fields, constructors, methods
Enums implemets interfaces but do not extend classes as they alreadt extend java.lang.Enum
Enums cannot be instantiated using new keyword
Enum constants are public, static, final by default
Enum constructors are private by default

46) Why enums are used instead of constants:
Type safety (cannot assign invalid values)

class AppConstants{
    public static final String STATUS_SUCCESS = "SUCCESS";
	public static final String STATUS_ERROR = "ERROR";
}

public class TestEnum{
	public static void main(String[] args) {
		Status status = Status.SUCCESS;
			
		// status = "INVALID"; //  Compie-time error
		// Only valid enum constants can be assigned
		System.out.println("Status: " + status);
	}
}	

47)transient Keyword:
	- It is applied to instance variables to indicate that tehy should not be serialized when an object is converted into a byet stream
	- Common use case: Sensitive data like passwords should not be serialized because serialization typically converts objects
	  into a format (plain text or easily readable streams) that can be stored or transmitted.
	- If such data is serialized, it can lead to security risks, as attackers could read or reuse the information from the serialized
	  file or  stream

48)Scanner class in Java:
Scanner class:
It is used to read and parse input from various sources such as Keyboard, file or String.
It has in-built tokenization and parse typing
It has many methods to read different data types like nextInt(), nextDouble(), next()
It has many methods to check the availability of data like hasNext(), hasDouble()
It is not thread-safe
It internally uses a regular expression engine, which is like an overhead for tokenization

49) Why does nextLine() seem to "skip" input after calling nextInt() or nextDouble() ?
Because Scanner uses whitespace as a delimiter, methods like nextInt() consume only the token (e.g., 42)
and leave the newline (\n) in the buffer. The next call to nextLine() immediately consumes that leftover newline
and returns an empty string - it looks like input was skipped, but it's just the newline being read.

Issue:
Scanner sc = new Scanner(System.in);
int num = sc.nextInt();
String line = sc.nextLine();

Fix:
Scanner sc = new Scanner(System.in);
int num = sc.nextInt();
sc.nextLine();
String line = sc.nextLine();

50)BufferedReader class in Java:
BufferedReader class in Java is part of an java.io package
It is used to read data from a character-input stream.
It reduces the overhead in performance by reducing the number of I/O operations.
We can think of it like a middleman with a storage bin. Instead of going to the source file for every single character,
it grabs a large chunk of data at once and stores it in an internal buffer
While it has a default size (usually 8 KB), you can specify a custom size depending on your needs.

To use it we wrap it around a FileReader

BufferedReader bufferedReader = new BufferedReader(new FileReader("sms.txt"));
BufferedReader br = new BufferedReader(new FileReader("C:\\Users\\Acer\\Documents\\testing.txt");


50)Scanner class vs BufferedReader class in Java
Feature:			BufferedReader   			Scanner
Speed:				Very fast (large buffer)	Slower (parses data using regex)
Data Types:			Reads only Strings			Can parse primitives (nextInt(), etc.)
Thread Safety:		It is synchronized 			Not synchronized
Use Case:			Reading large text files	Parsing user input or small files

51)Why BufferedReader/BufferedInputStream is faster than a FileReader/FileInputStream
Because FileReader for fetching 8kb of data for each character byte, it will make a trip to the disk.
But in case of BufferedReader, it loads a default 8kb of data from the disk at once which is thousands times faster.
Our code will use that data and if more data is there to be fetched it will make more trips but in every way,it is a
lot faster than fetching data from the disk.
Fetching something from the memory(RAM) is way faster than fetching it from the disk as BufferedReader maintains able
memory buffer for fetching data

52)FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream
FileInputStream, FileOutputStream:
These are low-level byte streams used to read and write raw binary data (8-bit bytes) directly
from and to a file on the physical disk.

These are high-level wrapper streams (also known as Filter Streams) that sit on top of a FileInputStream or FileOutputStream to provide a memory buffer.
Instead of hitting the disk for 1 byte, BufferedInputStream reads a large block (typically 8KB) into a memory array (RAM) all at once. Your application then reads from that fast RAM instead of the slow disk.

53)Serialization/Deserialization in Java ?
Serialization is the process of converting an object's state into a byte stream.
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(fileName))
out.writeObject(user);

Deserialization is the process of converting/recreating the object from the byte stream.
ObjectInputStream in = new ObjectInputStream(new FileInputStream(fileName))){
User deserializedUserObj = (User)in.readObject();

54)Regular Expressions in Java:
A Regular Expression is a powerful string of characters that forms a search pattern. In Java, it is used to perform "Pattern Matching"â€”searching, editing, or manipulating text based on complex rules.

The Java Regex Engine (java.util.regex)
Java uses three main components to handle regex:

Pattern Class: The compiled representation of a regex. To improve performance, you "compile" a pattern once and reuse it.
Matcher Class: The engine that interprets the pattern and performs match operations against an input string.
PatternSyntaxException: Thrown if the regex syntax is invalid.

55)Building Blocks of a Regex Pattern
Symbol,  Meaning
^     Start of a string
$     End of a string
.     Any single character
\d    Any digit (0-9)
\w    Any alphanumeric character (plus underscores)
\s    Any whitespace (space, tab, newline)
*	  Zero or more of the preceding element
+     One or more of the preceding element
?     Zero or one of the preceding element

56)What are Quantifiers in Regex Patterns
In Regular Expressions, Quantifiers are special symbols that specify how many times a particular character, group, or character class must appear in the input string for a match to occur.

The Three "Modes" of Quantifiers:
Greedy
Reluctant(Lazy)
Possessive

Few Problems Solved on Regex Patterns:
DuplicateWord Problem
ExtractNumbers Problem
GreedyVsLazyDemo
ValidUsername
ValidateAndExtractData

57)Throwable, Error,Compiletime Error, RuntimeError and Exception in Java:
Throwable class is the superclass of all errors and exception classes in Java
Direct Subclasses: Errors, Exception.
Any objects that are instances of this class can be thrown by the JVM.

Error, Compiletime Error, RuntimeError:
Error represents a serious problem in Java which leads to termination of the program and cannot be handled
by a program.
Errors are almost fatal and beyond the programmer's control to handle at the runtime as this happens at the runtime.
Eg- OutOfMemoryError, StackOverflowError.

CompileTimeError, RuntimeError these are concepts, there is no certain class named on this.
CompileTimeError is something which happens at the compile time due to syntax error.
RuntimeError is any problem that happens while the program is running (after successful compilation). Under this big umbrella, you have two different paths:
The Error Path: Serious, fatal JVM problems (like OutOfMemoryError).
The Exception Path: Logic problems (like NullPointerException).

Exception in Java:
Exception is the unwanted or unexpected event which disrups normal flow of the code.
Exeption Handling is a way/technique to handle these exceptions which will not disrupt the regular flow of our code.

There are 2 types of Exception: i)Checked Exception ii)Runtime Exception
Checked Exception: Exception which are checked at the compile-time.
For Checked exception, we need to write extra code to handle that exception and even if we don't write,
the compiler won't compile the program.

Eg - ClassNotFoundException, IOException, FileNotFoundException, SQLException

Unchecked Exception: Exception which occurs at the runtime are termed as Unchecked Exceptions.
For Unchecked exception, if we don't write extra code to handle the exception, the compiler does not
force us to write the extra code and without that code itself, it compiles the code.

Eg - ArithmeticException, ArrayIndexOutOFBunds, NullPointer Exception etc.

58)Difference between Error and Exception class in Java
Nature:
Error: Fatal/System-level. Indicates a failure in the JVM or environment.
Exception: Logic-level. Indicates a problem in the code or external inputs.

Recoverability:
Error: Program usually terminates immediately
Exception: Recoverable as program will not terminate if we handle the code which might throw an exception

Handle:
Error: Cannot be handled within a program, never try to catch an error
Exception: Can be handled using different exception handling techniques such as try-catch, throw, throws, finally

59)Exception Handling Techniques in Java. Explain
i)try-catch block:
try-catch block is one of the techniques for exeption handling.
Generally we put the try-catch block in some part of the code where we expect the exception to occur.

- Java Virtual Machine starts executing the code inside the try block.
- If an exception occurs, the remaining code in the try block is skipped, and the JVM starts looking for the matching  catch block.
- If a matching catch block is found, the code in that block is executed.
- After the catch block, control moves to the finally block (if present).
- If no matching catch block is found the exception is passed to the JVM default exception handler.
- The finally block is executed after the try catch block. regardless of whether an exception occurs or not.

throw:
throw keyword is used to throw an exeption explicitly.
throw keyword is generally used inside a function
It can throw both checked and unchecked exceptions
throw keyword is generally used to throw custom exceptions.
syntax of the throw keyword include the instance of the Exception to be thrown.
It stops the current flow of execution immediately.

throws:
throws keyword is used to declare multiple exceptions alongside a method to let the caller method know
that this function might throw one of these listed exceptions
throws keyword is used in the method signature itself.
throws keyword is used to declare the checked exceptions only.
It forces the caller to handle the declared exceptions.

finally:
finally block is always executed, regardless of whether an exception occurs or not.
finally block is generally used to close databaseconnections , resources or in general for resource cleanup purposee.

59)can we override static method and why?
No, we cannot override static methods
So static methods belongs to the class and static methods are loaded when class is loaded in the classpath which is also termed as early binding. At that stage, the compiler doesn't know what objects will be actually created on the heap at runtime, it only knows the type of the variable we have declared. So, because the static methods belongs to the  class, the compiler assumes that the method should be pulled from the class type of the reference variable so if it is
Parent obj = new Child();
obj.display();
It will only check what is the type of obj that is Parent and the compiler assues it is obj.display() but if it was method overriding, it would have checked the new Child() and would have executed child.display()

60)Young Gen(Eden Space, Survivor Space - S0,S1), Old Gen, Metaspace, PermGen (Part of Memory Management)?
The Heap is where all the objects live:
It is divided into generations: Young Gen, Old Gen
Young Gen:
All the objects are created in Young Generation.
It is further divided into:
Eden Space, Survivor Space 0(S0) and Survivor Space 1 (S1)
When we create an object, it actually borns in the Eden Space.
Then a Minor Garbage Collection happens and then it checks:
for the objects which are no longer used, are deleted
the objects which still survives, moves to S0
Then another Minor GC happens, where the garbace collector looks for the objects in Eden and S0.
Again the objects which survives this , moves to S1, s0 is then cleared entirely

Old Gen:
Once an object survives enough rounds of Garbage Collection in S1.
The default is usually 15 rounds of cycle(of garbage collection),
then that object gets promoted to the Old gen.
This area is much larger than the Young Gen.
When it fills up, a Major GC (or Full GC) occurs, which is much slower and "stops the world"

61)What happens during object promotion to Old gen ?
i)Primary Trigger:
When an object in the Young Gen survives a Minor GC, the JVM increments the count of it like the age of an object.
Now, the threshold of it is by default 15. So, when after surviving multiple GC's, it breaks the threshold, the JVM
promotes such an object to the Old gen
ii)Emergency Trigger:
Sometimes, even after a minor GC in Eden Space,
if the JVM sees the surviving objects are too big to fit into S0 or S1,
it promotes those objects to old generation which is also termed as premature promotion
iii)Large Object Trigger:
Sometimes,the objects are so massive that the GC realizes that if these objects are moved into Eden Space,
then a GC would happen immediately, so it directly promotes the object to the Old Generation.

62)Mark and Sweep Algorithm, Issue with it and solution:
Algorithm happens in 2 phases: Marking and Sweeping
Marking:
The JVM starts from a set of GC Roots(active threads, local variables on the stack, static variables)
and then it follows each references to check if the object is still active.
Each object has a hidden marked bit(either 0 or false)
Whenever the JVM finds the reachable objects, it flips it's bit to 1 or true.
At the end of this phase, all the reacheable objects will be set to 1

Sweeping:
Now, the JVM scans the heap and checks for the objects whose bit is still 0.
The objects which are no longer used in our program(unreacheable) are the ones whose bit is still 0.
JVM then reclaims those objects and adds the reclaimed memory to the Free list for future use.

There is an issue with the Mark and Sweep Algorithm: Fragmentation.
After the "Sweep" phase, our memory might look like a slice of Swiss cheeseâ€”lots of small holes
where objects used to be.
If you then try to create a very large array, the JVM might fail to find
a contiguous (connected) block of memory large enough to fit it, even if the total free space is plent

The Solution: Most modern Java collectors use Mark-Sweep-Compact. They add a third "Compact" phase to "push" all surviving objects to one end of the heap, leaving one big, clean block of free space at the other end.


63)PERMGEN, METASPACE:
i)PERMGEN:
- It is introduced in Java 7 or older versions.
- It is part of the Heap Memory
- It had a fixed maximum size within the heap(set by -XX:MaxPermSize).
- It stored data like class metadata, static variables, constant pool

Issue: The issue with PERMGEN was it used to run out of space which used to result in
OutOfMemoryError whenever we loaded too many classes in the memory(common in SpringBoot framework applications)
as it was part of the Heap Memory and had a fixed maximum size

ii)METASPACE:
- It is introduced in Java 8 and used in latest versions as well.
- It is part of the native memory or depends on the system's physical memory instead of heap memory
- It stores data like class's metadata
- It is auto-resizable as much as the system's physical memory allows
- By moving class metadata out of the Heap and into Native Memory, the "PermGen Space" crash was virtually eliminated.
If you need more space for classes, the JVM just asks the Operating System for more RAM.

64)Are User-defined Exceptions Compile time or Runtime exceptions ?
User-defined exceptions are the custom exceptions which allows us to write a more maintainable and readable way of exception handling. The class we will be using for user-defined exception needs to extend Exception or RuntimeException
class. If it's extends Exception class, it is a compile-time exception and if it extends RuntimeException class, it is a
Runtime exception class.

65)Rules of Exception-Handling with Method Overriding?
Rule 1: Parent method declares NO exception
If the superclass method does not declare an exception, the overriding subclass method cannot declare any Checked exceptions. It can, however, declare Unchecked (Runtime) exceptions.

Rule 2: Parent method declares a Checked exception
If the superclass method declares a checked exception, the subclass has three options:

Declare the same exception.

Declare a subclass (child) of that exception.

Declare no exception at all.

Illegal: The subclass cannot declare a broader (Parent) checked exception.

66)@ExceptionHandler, @RestControllerAdvice Exeption-Handling
@ExceptionHandler:
It works only for the specific controller as we will be using a method with @ExceptionHandler annotation in the same controller
High Maintainence code, High Redundancy as the same code we need to write in each Controller
Unique code for a specific Endpoint

Code:
@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")
    public String getUser(@PathVariable String id) {
        throw new ResourceNotFoundException("User not found");
    }

    // THIS ONLY WORKS FOR EXCEPTIONS THROWN IN THIS CLASS
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<String> handleLocalError(ResourceNotFoundException ex) {
        return ResponseEntity.status(404).body("Local Handler: " + ex.getMessage());
    }
}

@RestControllerAdvice:
It works globally not only for a specific controller as we will be using a separate class where we can mention the types of Exception we want to handle and calling that exception from any controller will work
Low Maintainence Code, Less Redundant as we write once to protect the whole application
Standardized error handling for the whole API.

Code:
@RestControllerAdvice
public class GlobalExceptionHandler {
    // Handle specific custom exceptions
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex){
        ErrorResponse error = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(),
                ex.getMessage(),
                System.currentTimeMillis()
        );
        return new ResponseEntity<>(error,HttpStatus.NOT_FOUND);
    }
}

@RestController
@RequestMapping("/users")
public class UserController {
    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable String id) {
        UserDTO user1 = null; // Simulating a database lookup that failed

        if (ObjectUtils.isEmpty(user1)) {
            // Because this is a @RestController,
            // Spring will intercept this throw and send it to your @RestControllerAdvice
            throw new ResourceNotFoundException("User Not Found with ID: " + id);
        }
        return ResponseEntity.ok(user1);
    }
}

67)Steps For Exception Handling
1. Create a Custom Exception class
2. Define a Standard Error Response
3. Step 3: The Global Exception Handler

68)Collection Framework in Java:
The Collection Framework in Java is a unified architecture consisting of classes and interfaces designed for storing and manipulating data. Iterable and Collection are the root interfaces, which are implemented by structures like List, Set,and Queue. While Map is a core part of the framework, it is unique because it does not extend the Collection interface. Additionally, the framework includes the Collections utility class, which provides static methods for common tasks like sorting, searching, and synchronizing collections.

69)Architecture of the Collection Framework:
Architecture is divided into 2 categories: Collection hierarchy and Map hierarchy
Iterable Interface:
		Collection Interface: (Collection Interface extends the Iterable interface)
          1)List 2)Set 3)Queue/Deque (interface)
List: Classes -  1)ArrayList 2)Vector 3)Stack 4)LinkedList
Set: Classes - 1)HashSet 2)EnumSet 3)LinkedHashSet 4)TreeSet
Queue: Classes - 1)PriorityQueue
  DeQue: Classes - 1)ArrayDeque 2)LinkedList

Map Interface(It does not extend the Collection interface):
 1)Hashtable 2)HashMap 3)LinkedHashMap 4)TreeMap (Classes)

70)List Interface:
List is a sub-interface of the Collection interface.
It allows ordered insertion of elements - element inserted first will be at index 0.
It allows duplicates.
It allows index-based access of elements.
Most of the implementing classes allows null values.
ArrayList, Vector, Stack, LinkedList implements the List Interface

71)ArrayList: It is a class which implements the List interface
i)It is dynamic in nature which means it can grow it's size automatically based on the number of elements
ii)It allows duplicate elemets
iii)It allows any number of null values.
iv)It maintains the insertion order
v)It is not thread-safe(for thread safe we use Vector or Collections.synchronizedList())
vi)It allows random access of elements in O(1) time complexity.

Internal Working of an ArrayList:
Whenever an arraylist is created and the first element is added, internally an array of size 10 gets created.
Whenever the 11th element is added, a new array with 50% more size gets created (New array = Old + (Old/2)).
Then all the elements from the old array is copied into the new array.
Then the old array is dumped and garbacge collected.

72)Vector: It is a class which implements the List interface
i)Vector internally uses an object array as ArrayList
ii)Vector is dynamic in nature
iii)Vector allows duplicate elements.
iv)Vector allows as much as null values possible
v)It maintains the insertion order
vi)It is synchronized in nature and that's why slower than ArrayList
vii)It also allows direct/random access of elements in O(1) time complexity using indexes

Internal Working of Vector:
It is totally similar to ArrayList apart from one difference:
In Vector, whenever the 11th element is added, a new array double the size of the old array gets created.
Then the elements of the old array gets copied into the new array.

73)Stack: It is a class which extends the Vector class.
i)It is also dynamic in nature.
ii)It allows duplicate values.
iii)It allows as much as null values possible.
iv)It is also synchronized in nature as it extends the Vector class.
v)It maintains LIFO order(Last-In-First-Out)
vi)It maintains the insertion order.
vii)ArrayDeque is more recommended than to use Stack.
Because Stack extends Vector, it inherits methods that it shouldn't have, like add(index, element).
This allows you to insert an element into the middle of a stack, which violates the LIFO principle.
It is also slower as compared to ArrayDeque as it has some overheads due to inheriting the Vector class
and synchronized nature.
viii)Internal Working of Stack is totally similar to that of a Vector

74)LinkedList:It is a class which implements the List and DeQueue interface
It internally implements the Doubly LinkedList which has reference to two elements - previous and next element.
It can be executed as List,Stack and a Queue.
It is also dynamic in nature.
It maintains the insertion order
It allows duplicate elements.
It allows null values.
It is not synchronized in nature
It does not allow random access we need to start from the beginning and traverse through each element
to find the element. O(n) time complexity
LinkedList has more memory overhead as every node has to store the element/data plus two pointers.
Time Complexity is O(1) to add any element

Internal Working of a LinkedList:
It internally uses a private Inner Class Node.
It has three fields item:
The actual data, next: A pointer to the next node, prev: A pointer to the previous node.
Head and Tail: The LinkedList class maintains two pointers: first (Head) and last (Tail).
When we add a new element, a new Node object gets created,
then the next pointer of the current last element is set to the new Node object and
then the prev pointer of the new Node Object is updated to the old node


75)How LinkedList acts both as a Stack and Queue?
Because it implements Deque, you get extra methods that ArrayList doesn't have:
addFirst() / addLast()
removeFirst() / removeLast()
peekFirst() / peekLast()
So Stack works on LIFO principle and Queue works on FILO principle.
Both we can achieve with the help of these methods

76)Set:
i)It is a sub-interface of the Collection interface.
ii)It does not allow duplicate elements
iii)It allows at most one null element
iv)It does not maintain insertion order(Unordered collection of elements)
v)It is implemented by classes like HashSet, LinkedHashSet, TreeSet

77)HashSet:It is a class which implements the Set interface
i)It does not allow duplicate elements
ii)It allows at most one null element
iii)It is not synchronized in nature
iv)It does not maintain insertion order
v)It internally uses HashMap and the concept of hashing

Internally Working of HashSet:
When the HashSet is instantiated (the constructor) - new HashSet(), it internally creates a HashMap.
The 'add' Operation: When you call set.add(element), the HashSet actually calls map.put(element, PRESENT).
The element we add becomes key in the Hashmap
PRESENT is like a dummy object which is used to fillup the value section for each newly added element.
Now whenever in the internal map, put method is executed, for the newly added element,
internally the map calls the hashcode() method to generated the hashcode. After that based on some math formula and
calculation, a bucket no. is given for that particular element.

If in that bucket, an element is not existing, then the new element is added in the bucket directly
If in that bucket, an element already exists, then the equals() method comes into picture, where it is checked
new_element.equals(existingObject) -> if it is equal, then the element is just replaced in the bucket.
if it is not equal, then the element is added in the same bucket(linking the old one with the new one)

Time complexity of manipulation:O(1) - Average case(Fastest)
Time complexity of traversing:O(n+h) -> n:no. of elements, h:no. of buckets

78)LinkedHashSet:It is also a class which implements the Set Interface
i)It does not allow duplicate elements
ii)It maintains the insertion order as internally it uses Linkedlist
iii)It allows at most one null value
iv)Internal Structure: It internally uses a LinkedHashMap.
This is important because a LinkedHashMap already combines a Hash Table (for $O(1)$ lookup) and a Doubly Linked List (for order).
v)It is fast for iteration as compared to HashSet but it is slower for manipulation(insertion/deletion)
vi)It is not synchronized in nature

Time Complexity of manipulation:O(1) - Fast but slower than HashSet
Time Complexity of traversing: O(n)

79)TreeSet:
i)It does not allow duplicate elements
ii)It maintains the sorted order of elements
iii)It does not allow null values
iv)It internally uses a TreeMap and the TreeMap uses a Red Black Tree(Self-balancing tree)
v)It is not synchronized in nature
vi)Slower than HashSet and LinkedHashSet
vii)It does not use hashCode() or equals(). It uses compareTo() or compare().
If compareTo() returns 0, the element is considered a duplicate and not added.

Internal Working of TreeSet:
Similar to HashSet, a TreeSet internally uses a TreeMap.
Whenever we add an element to the TreeSet, the element gets added as a key in the TreeMap
where we keep a dummy object PRESENT in the value as part of each newly added element.
It internally uses a Red-Black Tree which is like a self-balancing tree.
It does not use hashing like hashcode() and equals() method but it uses Comparable(for natural ordering) and
Comparator(for custom ordering).
When we add an element, it compares the element with the currentNode.
if(element.compareTo(currentNode)) ->
negative - element will be added to the left of tree
positive - element will be added to the right of tree
0 - it means the element is a duplicate and it will not be added(but value for that key will be replaced
but in a hashset value is always the same for every key - so value anyway will not be replaced)
The Red-Black Tree algorithm performs "rotations" to re-balance itself when one branch becomes
much longer than the other

Time Complexity of Manipulation:O(logn)
Time Complexity of Traversing:O(n)

80)HashMap: It is a class which implements the Map Interface
i)It stores the data in key-value pairs
ii)It does not maintain the insertion order
iii)It internally uses a Hashtable
iv)It allows at most one null key and multiple null values
v)If two different values with same key is inserted, it will replace the old value with the new one.
vi)It is non-synchronized in nature

Internal Working of HashMap:
When we call map.put(key, value),
internally based on the key, it's hashcode gets calculated.
Then based on the hashcode and a math based formula, a bucket no. is calculated.
A node gets created and then,
if there is no element in the bucket -> new element gets added.
if there is already an element in the bucket -> equals() method is executed, then
if new_key.equals(existing_key) -> false (collision) -> the new element will be added in the same bucket using a linkedlist
if new_key.equals(existing_key) -> true -> the new_key value will replace the exisitng_key value.
(because key is the same here)
map.put(2,5)
map.put(2,6) -> as key is same, the bucket will contain the later added value of the key.

Time Complexity: Manipulation (Put/Get/Remove): $O(1)$ average.
Traversing: $O(n + h)$ (Elements + Buckets).

81)LinkedHashMap: It is a class which extends the HashMap class.
i)It maintains the insertion order
ii)It internally uses the Hashtable and Doubly LinkedList
iii)It is also non-synchronized in nature.
iv)It allows at most one null key and multiple null values
v)It is slower as compared to the HashMap as it contains 2 extra pointers

Internal Working of LinkedHashMap:
It internally uses the hashtable and doubly linkedlist.
It works similar as the HashMap but the only difference is,
suppose we have added an element first -> it will go to Bucket 5
again  we add an element -> it goes to Bucket 7
In Hashmap, there will be no connection between these 2 buckets.
But in LinkedHashMap, these 2 buckets will be connected with a before and after pointer due to the Doubly LL.
The Node in Bucket 7 has a before pointer pointing to the Node in Bucket 5.

Time Complexity: Manipulation - O(1)
Traversing - O(n)

82)TreeMap:It is a class which implements the Map Interface
i)It maintains the natural sorted order of elements like based on the value of the keys inserted
ii)It is non-synchronized in nature
iii)It does not allow any null key unlike HashMap
iv)It internally uses a Red-Black tree i.e. a self-balancing tree
v)it is slower as compared to HashMap, LinkedHashMap because it must navigate through the branches of a tree.
vi)No Hashing: Unlike HashMap, it does not use hashing.It uses the compareTo() or compare() method to determine where a key belongs

Internal Working of TreeMap:
When we add an element in the TreeMap, the first element becomes the root node of the Tree.
Then we add the next element, if new_key < existing_node: it goes into the left branch of the tree
if new_key > existing_node: it goes into the right branch of the tree.
if new_key = existing_key/node: value of the new_key will replace the value of the existing_key
The Red-Black Tree itself performs rotations so that any one part of the tree is not becoming a long-chain.

83)Is it possible to change the access order of a LinkedHashMap?
Access Order of the LinkedHashMap can be changed:
 * if we use a true flag in the constructor of the LinkedHashMap as below
 * The most recent element in such a LinkedHashMap will be the recently touched one
 * even if we update a key or try to get the value of the key, that element will become the latest element.

84)Queues:It is an interface. It follows the FIFO(First-In-First-Out) principle.
Suppose for example, a person at the front of ticket counter line gets the first ticket.

We generally add any new element in a Queue from tail of the queue.

Almost every queue(like priority queue) does not allow null value

Almost every queue has 2 methods for execution:
one throws exception if it fails
other returns null/false if it fails
Methods:
Add -         add(e) (Throws exception),     offer(e)
Delete -      remove() (Throws exception),   poll()
top element - element()  (Throws exception), peek()

85)Types of Queue:
i)PriorityQueue
ii)Linkedlist
iii)Deque(interface extends Queue interface)
      ArrayDeque implements Deque interface

86)PriorityQueue:
i)It is a queue which follows the natural sorting order.
(If we print the PriorityQueue, it might give us the elements in a random order but
if we peek the PriorityQueue, it will return the smallest element in the queue)
ii)It is non-synchronized in nature
iii)It does not allow null values. Adding a null value will give NPE as it won't be able to compare
iv)The smallest element in this queue will always have the highest priority.
v)It allows duplicate values.

Internal Working of PriorityQueue:
A PriorityQueue internally uses a Binary Heap(specifically Min-Heap by default)
We visualize it as a tree but internally it uses a dynamic object[] array.
For element at index i,
2i+1 is the left child
2i+2 is the right child
(i-1)/2 is the Parent element

When you call add() or offer(), the PriorityQueue follows these steps:
Placement: The new element is placed at the first available spot at the end of the array (the bottom-right of the tree).
Comparison: It compares itself with its Parent.
The Swap: If the new element is smaller than its parent, they swap places.
Repeat: This continues until the element finds a parent smaller than itself or it becomes the new Root.
Removing an Element: "Sift-Down" (Heapify Down)

When you call poll(), the PriorityQueue must maintain the tree structure:
The Exit: The element at queue[0] (the root) is removed and saved to be returned.
The Replacement: The last element in the array is moved to the empty Root position (queue[0]).
Comparison: This new root compares itself with its two children.
The Swap: It swaps places with the smallest of its children (to ensure the minimum stays at the top).
Repeat: This "sifts down" until the element is smaller than both its children.

Imagine your array is [10, 30, 20].
You add(5).
It goes to the end: [10, 30, 20, 5].
It compares with parent 30 (at index 1). Since 5 < 30, they swap: [10, 5, 20, 30].
It compares with parent 10 (at index 0). Since 5 < 10, they swap: [5, 10, 20, 30].

Final Array: [5, 10, 20, 30]. The smallest is now at the top!

Addition:O(log n)
Subtraction:O(log n)
peek:O(1)

Reverse Order In PriorityQueue:
We can use a Comparator to get the elements in a PriorityQueue in the reverse order i.e. max heap
where the largest element will have the highest priority

PriorityQueue<Integer> maxHeapPriorityQueue = new PriorityQueue<>(Collections.reverseOrder());


87)ArrayDeque:It is a class which implements the Deque interface
i)It internally uses a resizable circular array
ii)We can add elements both at the start and end of the array
iii)It does not allow null values
iv)It is non-synchronized in nature
v)It allows duplicate elements
vi)It is faster than Linkedlist as it is not having the overhead of maintaining 2 pointers
vii)It is also faster than Stack

Internal Working of ArrayDeque:
It internally uses a dynamic array which is also termed as circular array.
Initially it creates an array of size 16
It basically maintains 2 variable pointers.
In an ArrayDeque, the "pointers" are actually just two simple integer variables: head and tail.
head: An int storing the index of the first element.
tail: An int storing the index where the next element will be added.

When we add an element to the front,
the head doesn't shift all the other elements (which would be slow). Instead, it just calculates:
head = (head - 1) & (elements.length - 1)
It literally just moves the "start" marker one spot to the left!

Imagine an internal array of size 8.
Start: You add "A", "B", "C".
head is at 0.
tail is at 3.

The "Circular" Moment: You decide to addFirst("Z").
In a straight array, there is no space before index 0.
In a Circular Array, the head pointer simply "jumps" to the very last index (Index 7).

head = (head - 1) & (elements.length - 1) -> (0-1) & (7-1) -> 6
Now your array looks like this:
[A, B, C, _, _, _, _, Z]
Index: 0, 1, 2, 3, 4, 5, 6, 7

Even though "Z" is physically at the end of the array, logically it is the First element because the head pointer says so.
How it stays dynamic:
When head==tail happens, the dynamic array resizes it by doubling it's size
Also, it copies the elements from the head->end(arr.length-1) to the new array from the old array.
Then, it copies the elements from the start(0th index)->tail to the new array from the old array.
Then again, when we add an element, the above logic resumes.

So why it's circular because when we add elements,
head goes back and tail goes forward and when the array is full we see head=tail

88)How ArrayDeque can be used both as a Stack and as a Queue?
i)ArrayDeque has methods like push(e) which will internally call addFirst()
ii)It has methods like pop(e) which will internally call pollFirst()
So suppose I added 2 elements "A","B" using push(e) 2 times -> "B" -> "A"
then I removed 1 element using pop() -> It  will remove the topmost element tha is "B"
In this way, it behaves like a STACK

iii)Similarly for Queue:
When we call offer(e) -> it executes addLast()
When we call poll() -> it execvutes pollFirst()

So, if I add 2 elements -> "A","B" -> Queue view -> "A" -> "B"
If i call poll() -> "A" WILL BE REMOVED so first in first out rule is followed as "A" is added initially

89)Iterator,ListIterator, forEach loops:
Iterator:It is an interface which is used to iterate any Collections
i)It iterates only in the forward direction
ii)It can be used to remove any element while traversing the Collection
iii)It cannot be used to add or replace any element
iv)It has methods like hasNext(),next(),remove()

ListIterator:It is a sub-interface of the Iterator interface which is used to traverse the List Interface
i)It is bi-directional, can traverse both forward and backward
ii)It is used to add,replace or remove an element in a list while traversing
iii)It has access to indexes unlike Iterator
iv)It has methods like hasPrevious(), previous(), hasNext(), next(), add(), replace(), remove(), nextIndex(), previousIndex()

forEach:forEach loop is a clean way to write a for loop for traversing the collections
i)It makes the code more readable.
ii)Internally Java converts it into an Iterator
iii)It cannot be used to remove any element while traversing the Collection

90)Split-Iterator:
A Spliterator is used to traverse and partition elements of a source. It is the engine behind Java 8 Streams, especially when you use .parallelStream().
It runs on the principle of Divide and Conquer

91)Fail-Fast and Fail-Safe Iterator:
First of all, these are not specific iterators or any property of the iterators.
These is the behaviour of an iterator based on the type of Collection we are using.
Fail-Fast: Iterators will throw ConcurrentModificationException if we are trying to rmeove an element
during traversal of certain Collection class.
eg - ArrayList, HashSet, HashMap
It works on the original copy of the data(collection class)

Fail-Safe:Iterators will work fine and won't throw any exception if we try to remove an element
while traversing the collection class.
It works on the copy of the original data.
Everytime we modify the collection, it creates a copy of the original data.
eg - CopyOnWriteArrayList, ConcurrentHashMap
It also creates a memory overhead.
For eg - If there is a list of 1 million items, adding/removing one will result in creating the copy of 1 million items

May work on outdated data if multiple threads are working simultaneously as it works on the copy of the original data
and might not be aware of the modified data while traversing and doing modification on the list.
